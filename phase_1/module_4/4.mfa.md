# Module 4 - Day 5: Multi-Factor Authentication (Complete)

**Part of:** Module 4 - Authentication & Authorization  
**Duration:** Day 5 of 7

---

## üìñ Section 2: SMS-Based MFA

### 5.5 SMS MFA Implementation with Twilio

**When to use SMS MFA:**

- ‚úÖ Better UX (no app download needed)
- ‚úÖ Good for consumer apps
- ‚ö†Ô∏è Less secure than TOTP (SIM swapping attacks)
- ‚ö†Ô∏è Costs money per SMS

**Dependencies:**

```bash
npm install twilio
npm install --save-dev @types/twilio
```

**Twilio Configuration:**

```typescript
// src/config/twilio.ts
import twilio from "twilio";

export const twilioClient = twilio(
  process.env.TWILIO_ACCOUNT_SID!,
  process.env.TWILIO_AUTH_TOKEN!
);

export const twilioConfig = {
  serviceSid: process.env.TWILIO_VERIFY_SERVICE_SID!, // For Verify API
  fromNumber: process.env.TWILIO_PHONE_NUMBER!,
  codeLength: 6,
  codeExpiry: 300, // 5 minutes
};
```

**SMS MFA Service:**

```typescript
// src/services/sms-mfa.service.ts
import { twilioClient, twilioConfig } from "../config/twilio";
import { pool } from "../config/database";
import crypto from "crypto";

export class SMSMFAService {
  /**
   * Send SMS code using Twilio Verify API (recommended)
   */
  static async sendVerificationCode(phoneNumber: string): Promise<void> {
    try {
      await twilioClient.verify.v2
        .services(twilioConfig.serviceSid)
        .verifications.create({
          to: phoneNumber,
          channel: "sms",
        });
    } catch (error) {
      console.error("Twilio error:", error);
      throw new Error("Failed to send verification code");
    }
  }

  /**
   * Verify SMS code using Twilio Verify API
   */
  static async verifyCode(phoneNumber: string, code: string): Promise<boolean> {
    try {
      const verification = await twilioClient.verify.v2
        .services(twilioConfig.serviceSid)
        .verificationChecks.create({
          to: phoneNumber,
          code,
        });

      return verification.status === "approved";
    } catch (error) {
      console.error("Verification error:", error);
      return false;
    }
  }

  /**
   * Alternative: Manual SMS implementation (if not using Verify API)
   */
  static async sendManualSMS(phoneNumber: string): Promise<string> {
    // Generate 6-digit code
    const code = crypto.randomInt(100000, 999999).toString();

    // Store in database with expiry
    const query = `
      INSERT INTO sms_verification_codes (phone_number, code, expires_at)
      VALUES ($1, $2, CURRENT_TIMESTAMP + INTERVAL '5 minutes')
      ON CONFLICT (phone_number) 
      DO UPDATE SET code = $2, expires_at = CURRENT_TIMESTAMP + INTERVAL '5 minutes', created_at = CURRENT_TIMESTAMP
    `;

    await pool.query(query, [phoneNumber, code]);

    // Send SMS
    await twilioClient.messages.create({
      body: `Your verification code is: ${code}. Valid for 5 minutes.`,
      from: twilioConfig.fromNumber,
      to: phoneNumber,
    });

    return code;
  }

  /**
   * Verify manual SMS code
   */
  static async verifyManualCode(
    phoneNumber: string,
    code: string
  ): Promise<boolean> {
    const query = `
      SELECT id
      FROM sms_verification_codes
      WHERE phone_number = $1 
        AND code = $2
        AND expires_at > CURRENT_TIMESTAMP
        AND verified = FALSE
    `;

    const result = await pool.query(query, [phoneNumber, code]);

    if (result.rows.length > 0) {
      // Mark as verified
      await pool.query(
        "UPDATE sms_verification_codes SET verified = TRUE WHERE id = $1",
        [result.rows[0].id]
      );
      return true;
    }

    return false;
  }

  /**
   * Save phone number for user
   */
  static async savePhoneNumber(
    userId: string,
    phoneNumber: string
  ): Promise<void> {
    const query = `
      UPDATE users 
      SET phone_number = $1, phone_verified = TRUE 
      WHERE id = $2
    `;

    await pool.query(query, [phoneNumber, userId]);
  }
}
```

**Database Schema for SMS MFA:**

```sql
-- Add to users table
ALTER TABLE users ADD COLUMN phone_number VARCHAR(20);
ALTER TABLE users ADD COLUMN phone_verified BOOLEAN DEFAULT FALSE;
ALTER TABLE users ADD COLUMN sms_mfa_enabled BOOLEAN DEFAULT FALSE;

-- SMS verification codes (if not using Twilio Verify API)
CREATE TABLE sms_verification_codes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phone_number VARCHAR(20) UNIQUE NOT NULL,
  code VARCHAR(6) NOT NULL,
  verified BOOLEAN DEFAULT FALSE,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sms_codes_phone ON sms_verification_codes(phone_number);
CREATE INDEX idx_sms_codes_expiry ON sms_verification_codes(expires_at);
```

**SMS MFA Controller:**

```typescript
// src/controllers/sms-mfa.controller.ts
import { Request, Response } from "express";
import { SMSMFAService } from "../services/sms-mfa.service";
import { User } from "../models/user.model";

export class SMSMFAController {
  /**
   * Step 1: Send verification code to phone
   */
  static async sendCode(req: Request, res: Response) {
    try {
      const userId = req.user!.userId;
      const { phoneNumber } = req.body;

      // Validate phone number format
      if (!phoneNumber || !/^\+\d{10,15}$/.test(phoneNumber)) {
        return res.status(400).json({
          error: "Invalid phone number format. Use E.164 format (+1234567890)",
        });
      }

      // Send verification code
      await SMSMFAService.sendVerificationCode(phoneNumber);

      res.json({
        message: "Verification code sent",
        phoneNumber: phoneNumber.replace(
          /(\d{2})(\d{3})(\d{3})(\d{4})/,
          "+$1 $2-$3-$4"
        ),
      });
    } catch (error) {
      console.error("Send SMS error:", error);
      res.status(500).json({ error: "Failed to send verification code" });
    }
  }

  /**
   * Step 2: Verify code and enable SMS MFA
   */
  static async verifyAndEnable(req: Request, res: Response) {
    try {
      const userId = req.user!.userId;
      const { phoneNumber, code } = req.body;

      // Verify code
      const isValid = await SMSMFAService.verifyCode(phoneNumber, code);

      if (!isValid) {
        return res.status(400).json({ error: "Invalid or expired code" });
      }

      // Save phone number and enable SMS MFA
      await SMSMFAService.savePhoneNumber(userId, phoneNumber);

      await pool.query(
        "UPDATE users SET sms_mfa_enabled = TRUE WHERE id = $1",
        [userId]
      );

      res.json({
        message: "SMS MFA enabled successfully",
        phoneNumber,
      });
    } catch (error) {
      console.error("SMS MFA enable error:", error);
      res.status(500).json({ error: "Failed to enable SMS MFA" });
    }
  }

  /**
   * Send login verification code
   */
  static async sendLoginCode(req: Request, res: Response) {
    try {
      const { userId } = req.body;

      // Get user's phone number
      const user = await User.findById(userId);

      if (!user || !user.phoneNumber) {
        return res.status(400).json({ error: "Phone number not found" });
      }

      // Send code
      await SMSMFAService.sendVerificationCode(user.phoneNumber);

      res.json({
        message: "Verification code sent",
        phoneNumber: user.phoneNumber.replace(
          /(\d{2})(\d{3})(\d{3})(\d{4})/,
          "+$1 ***-***-$4"
        ),
      });
    } catch (error) {
      console.error("Send login code error:", error);
      res.status(500).json({ error: "Failed to send code" });
    }
  }

  /**
   * Disable SMS MFA
   */
  static async disable(req: Request, res: Response) {
    try {
      const userId = req.user!.userId;
      const { password } = req.body;

      // Verify password
      const user = await User.findById(userId);
      const isValid = await user!.verifyPassword(password);

      if (!isValid) {
        return res.status(401).json({ error: "Invalid password" });
      }

      // Disable SMS MFA
      await pool.query(
        "UPDATE users SET sms_mfa_enabled = FALSE WHERE id = $1",
        [userId]
      );

      res.json({ message: "SMS MFA disabled" });
    } catch (error) {
      console.error("SMS MFA disable error:", error);
      res.status(500).json({ error: "Failed to disable SMS MFA" });
    }
  }
}
```

---

## üìñ Section 3: Email-Based MFA

### 5.6 Email MFA (Fallback Option)

**When to use:**

- Fallback when TOTP/SMS unavailable
- Less secure, but better than nothing
- Free to implement

**Email MFA Service:**

```typescript
// src/services/email-mfa.service.ts
import crypto from "crypto";
import { pool } from "../config/database";
import { EmailService } from "./email.service";

export class EmailMFAService {
  private static CODE_EXPIRY_MINUTES = 10;

  /**
   * Generate and send email code
   */
  static async sendCode(userId: string, email: string): Promise<void> {
    // Generate 6-digit code
    const code = crypto.randomInt(100000, 999999).toString();

    // Store in database
    const query = `
      INSERT INTO email_verification_codes (user_id, email, code, expires_at)
      VALUES ($1, $2, $3, CURRENT_TIMESTAMP + INTERVAL '${this.CODE_EXPIRY_MINUTES} minutes')
      ON CONFLICT (user_id)
      DO UPDATE SET 
        code = $3, 
        expires_at = CURRENT_TIMESTAMP + INTERVAL '${this.CODE_EXPIRY_MINUTES} minutes',
        attempts = 0
    `;

    await pool.query(query, [userId, email, code]);

    // Send email
    await EmailService.send({
      to: email,
      subject: "Your verification code",
      template: "mfa-code",
      data: {
        code,
        expiryMinutes: this.CODE_EXPIRY_MINUTES,
      },
    });
  }

  /**
   * Verify email code
   */
  static async verifyCode(userId: string, code: string): Promise<boolean> {
    // Check rate limiting (max 5 attempts)
    const checkQuery = `
      SELECT attempts
      FROM email_verification_codes
      WHERE user_id = $1 AND expires_at > CURRENT_TIMESTAMP
    `;

    const checkResult = await pool.query(checkQuery, [userId]);

    if (checkResult.rows.length === 0) {
      return false;
    }

    if (checkResult.rows[0].attempts >= 5) {
      // Delete expired code after too many attempts
      await pool.query(
        "DELETE FROM email_verification_codes WHERE user_id = $1",
        [userId]
      );
      return false;
    }

    // Verify code
    const query = `
      UPDATE email_verification_codes
      SET attempts = attempts + 1
      WHERE user_id = $1 
        AND code = $2
        AND expires_at > CURRENT_TIMESTAMP
      RETURNING id
    `;

    const result = await pool.query(query, [userId, code]);

    if (result.rows.length > 0) {
      // Delete used code
      await pool.query("DELETE FROM email_verification_codes WHERE id = $1", [
        result.rows[0].id,
      ]);
      return true;
    }

    return false;
  }
}
```

**Database Schema:**

```sql
CREATE TABLE email_verification_codes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  email VARCHAR(255) NOT NULL,
  code VARCHAR(6) NOT NULL,
  attempts INTEGER DEFAULT 0,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_email_codes_expiry ON email_verification_codes(expires_at);
```

---

## üìñ Section 4: Java/Spring Boot MFA Implementation

### 5.7 Complete Java TOTP Implementation

**Dependencies (pom.xml):**

```xml
<dependencies>
    <!-- TOTP -->
    <dependency>
        <groupId>com.warrenstrange</groupId>
        <artifactId>googleauth</artifactId>
        <version>1.5.0</version>
    </dependency>

    <!-- QR Code -->
    <dependency>
        <groupId>com.google.zxing</groupId>
        <artifactId>core</artifactId>
        <version>3.5.1</version>
    </dependency>
    <dependency>
        <groupId>com.google.zxing</groupId>
        <artifactId>javase</artifactId>
        <version>3.5.1</version>
    </dependency>
</dependencies>
```

**MFA Models:**

```java
// MFASecret.java
package com.mycompany.saas.model;

import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "mfa_secrets")
public class MFASecret {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(name = "user_id", unique = true, nullable = false)
    private String userId;

    @Column(nullable = false)
    private String secret;

    @Column(nullable = false)
    private Boolean enabled = false;

    @Column(name = "verified_at")
    private LocalDateTime verifiedAt;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    // Getters and setters
}

// MFABackupCode.java
@Entity
@Table(name = "mfa_backup_codes")
public class MFABackupCode {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(name = "user_id", nullable = false)
    private String userId;

    @Column(nullable = false)
    private String code;

    @Column(nullable = false)
    private Boolean used = false;

    @Column(name = "used_at")
    private LocalDateTime usedAt;

    // Getters and setters
}
```

**MFA Service:**

```java
// MFAService.java
package com.mycompany.saas.service;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;
import com.warrenstrange.googleauth.GoogleAuthenticator;
import com.warrenstrange.googleauth.GoogleAuthenticatorKey;
import com.warrenstrange.googleauth.GoogleAuthenticatorQRGenerator;
import com.mycompany.saas.model.MFABackupCode;
import com.mycompany.saas.model.MFASecret;
import com.mycompany.saas.repository.MFABackupCodeRepository;
import com.mycompany.saas.repository.MFASecretRepository;
import com.mycompany.saas.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.*;

@Service
public class MFAService {

    @Autowired
    private MFASecretRepository mfaSecretRepository;

    @Autowired
    private MFABackupCodeRepository backupCodeRepository;

    @Autowired
    private UserRepository userRepository;

    private final GoogleAuthenticator googleAuthenticator = new GoogleAuthenticator();
    private static final String APP_NAME = "My SaaS App";

    /**
     * Generate MFA secret for user
     */
    public Map<String, String> setupMFA(String userId, String userEmail) {
        // Generate secret
        GoogleAuthenticatorKey credentials = googleAuthenticator.createCredentials();
        String secret = credentials.getKey();

        // Create OTP auth URL
        String otpAuthUrl = GoogleAuthenticatorQRGenerator.getOtpAuthURL(
            APP_NAME,
            userEmail,
            credentials
        );

        // Save secret (not yet enabled)
        MFASecret mfaSecret = new MFASecret();
        mfaSecret.setUserId(userId);
        mfaSecret.setSecret(secret);
        mfaSecret.setEnabled(false);

        mfaSecretRepository.save(mfaSecret);

        Map<String, String> result = new HashMap<>();
        result.put("secret", secret);
        result.put("otpAuthUrl", otpAuthUrl);

        return result;
    }

    /**
     * Generate QR code image
     */
    public byte[] generateQRCode(String otpAuthUrl) throws Exception {
        QRCodeWriter qrCodeWriter = new QRCodeWriter();
        BitMatrix bitMatrix = qrCodeWriter.encode(otpAuthUrl, BarcodeFormat.QR_CODE, 300, 300);

        BufferedImage bufferedImage = MatrixToImageWriter.toBufferedImage(bitMatrix);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "PNG", outputStream);

        return outputStream.toByteArray();
    }

    /**
     * Verify TOTP code
     */
    public boolean verifyCode(String secret, int code) {
        return googleAuthenticator.authorize(secret, code);
    }

    /**
     * Enable MFA after verification
     */
    @Transactional
    public List<String> enableMFA(String userId, int verificationCode) {
        // Get secret
        MFASecret mfaSecret = mfaSecretRepository.findByUserId(userId)
            .orElseThrow(() -> new RuntimeException("MFA not set up"));

        // Verify code
        boolean isValid = verifyCode(mfaSecret.getSecret(), verificationCode);

        if (!isValid) {
            throw new RuntimeException("Invalid verification code");
        }

        // Enable MFA
        mfaSecret.setEnabled(true);
        mfaSecret.setVerifiedAt(LocalDateTime.now());
        mfaSecretRepository.save(mfaSecret);

        // Update user
        userRepository.updateMFAEnabled(userId, true);

        // Generate backup codes
        List<String> backupCodes = generateBackupCodes(userId, 10);

        return backupCodes;
    }

    /**
     * Generate backup codes
     */
    public List<String> generateBackupCodes(String userId, int count) {
        // Delete old codes
        backupCodeRepository.deleteByUserId(userId);

        List<String> codes = new ArrayList<>();
        SecureRandom random = new SecureRandom();

        for (int i = 0; i < count; i++) {
            // Generate 8-character code
            String code = String.format("%08d", random.nextInt(100000000));

            MFABackupCode backupCode = new MFABackupCode();
            backupCode.setUserId(userId);
            backupCode.setCode(code);
            backupCodeRepository.save(backupCode);

            codes.add(code);
        }

        return codes;
    }

    /**
     * Verify backup code
     */
    @Transactional
    public boolean verifyBackupCode(String userId, String code) {
        Optional<MFABackupCode> backupCode = backupCodeRepository
            .findByUserIdAndCodeAndUsed(userId, code, false);

        if (backupCode.isPresent()) {
            MFABackupCode bc = backupCode.get();
            bc.setUsed(true);
            bc.setUsedAt(LocalDateTime.now());
            backupCodeRepository.save(bc);
            return true;
        }

        return false;
    }

    /**
     * Disable MFA
     */
    @Transactional
    public void disableMFA(String userId) {
        mfaSecretRepository.deleteByUserId(userId);
        backupCodeRepository.deleteByUserId(userId);
        userRepository.updateMFAEnabled(userId, false);
    }

    /**
     * Check if MFA is enabled
     */
    public boolean isMFAEnabled(String userId) {
        return mfaSecretRepository.findByUserId(userId)
            .map(MFASecret::getEnabled)
            .orElse(false);
    }

    /**
     * Get MFA secret
     */
    public String getMFASecret(String userId) {
        return mfaSecretRepository.findByUserId(userId)
            .filter(MFASecret::getEnabled)
            .map(MFASecret::getSecret)
            .orElse(null);
    }
}
```

**MFA Controller:**

```java
// MFAController.java
package com.mycompany.saas.controller;

import com.mycompany.saas.service.MFAService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/mfa")
public class MFAController {

    @Autowired
    private MFAService mfaService;

    @PostMapping("/setup")
    public ResponseEntity<?> setupMFA(Authentication auth, @RequestBody Map<String, String> request) {
        String userId = (String) auth.getPrincipal();
        String email = request.get("email");

        try {
            Map<String, String> result = mfaService.setupMFA(userId, email);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "MFA setup failed"));
        }
    }

    @GetMapping("/qrcode")
    public ResponseEntity<byte[]> getQRCode(@RequestParam String otpAuthUrl) {
        try {
            byte[] qrCode = mfaService.generateQRCode(otpAuthUrl);
            return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_PNG)
                .body(qrCode);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping("/verify-enable")
    public ResponseEntity<?> verifyAndEnable(
            Authentication auth,
            @RequestBody Map<String, Integer> request) {
        String userId = (String) auth.getPrincipal();
        int code = request.get("code");

        try {
            List<String> backupCodes = mfaService.enableMFA(userId, code);
            return ResponseEntity.ok(Map.of(
                "message", "MFA enabled successfully",
                "backupCodes", backupCodes
            ));
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(Map.of("error", e.getMessage()));
        }
    }

    @PostMapping("/disable")
    public ResponseEntity<?> disableMFA(
            Authentication auth,
            @RequestBody Map<String, Object> request) {
        String userId = (String) auth.getPrincipal();

        try {
            mfaService.disableMFA(userId);
            return ResponseEntity.ok(Map.of("message", "MFA disabled successfully"));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Failed to disable MFA"));
        }
    }

    @GetMapping("/status")
    public ResponseEntity<?> getMFAStatus(Authentication auth) {
        String userId = (String) auth.getPrincipal();
        boolean enabled = mfaService.isMFAEnabled(userId);

        return ResponseEntity.ok(Map.of("mfaEnabled", enabled));
    }
}
```

---

## üìñ Section 5: Go MFA Implementation

### 5.8 Complete Go TOTP Implementation

**Dependencies:**

```bash
go get github.com/pquerna/otp
go get github.com/pquerna/otp/totp
go get github.com/skip2/go-qrcode
```

**MFA Service:**

```go
// services/mfa.go
package services

import (
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"fmt"
	"time"

	"github.com/pquerna/otp"
	"github.com/pquerna/otp/totp"
	qrcode "github.com/skip2/go-qrcode"
)

type MFAService struct {
	db *sql.DB
}

func NewMFAService(db *sql.DB) *MFAService {
	return &MFAService{db: db}
}

type MFASetup struct {
	Secret     string `json:"secret"`
	QRCode     string `json:"qrCode"` // Base64 encoded
	OTPAuthURL string `json:"otpAuthUrl"`
}

// GenerateSecret generates a new TOTP secret
func (s *MFAService) GenerateSecret(userEmail string, issuer string) (*MFASetup, error) {
	key, err := totp.Generate(totp.GenerateOpts{
		Issuer:      issuer,
		AccountName: userEmail,
		Period:      30,
		SecretSize:  32,
		Digits:      otp.DigitsSix,
		Algorithm:   otp.AlgorithmSHA1,
	})

	if err != nil {
		return nil, err
	}

	// Generate QR code
	png, err := qrcode.Encode(key.URL(), qrcode.Medium, 256)
	if err != nil {
		return nil, err
	}

	// Convert to base64
	qrCodeBase64 := base64.StdEncoding.EncodeToString(png)

	return &MFASetup{
		Secret:     key.Secret(),
		QRCode:     qrCodeBase64,
		OTPAuthURL: key.URL(),
	}, nil
}

// SaveSecret saves MFA secret (not yet enabled)
func (s *MFAService) SaveSecret(userID, secret string) error {
	query := `
		INSERT INTO mfa_secrets (user_id, secret, enabled)
		VALUES ($1, $2, false)
		ON CONFLICT (user_id)
		DO UPDATE SET secret = $2, enabled = false, updated_at = CURRENT_TIMESTAMP
	`

	_, err := s.db.Exec(query, userID, secret)
	return err
}

// VerifyCode verifies TOTP code
func (s *MFAService) VerifyCode(secret string, code string) bool {
	return totp.Validate(code, secret)
}

// EnableMFA enables MFA after verification
func (s *MFAService) EnableMFA(userID string, verificationCode string) ([]string, error) {
	// Get secret
	var secret string
	err := s.db.QueryRow(
		"SELECT secret FROM mfa_secrets WHERE user_id = $1",
		userID,
	).Scan(&secret)

	if err != nil {
		return nil, fmt.Errorf("MFA not set up")
	}

	// Verify code
	if !s.VerifyCode(secret, verificationCode) {
		return nil, fmt.Errorf("invalid verification code")
	}

	// Begin transaction
	tx, err := s.db.Begin()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	// Enable MFA secret
	_, err = tx.Exec(
		`UPDATE mfa_secrets
		 SET enabled = true, verified_at = CURRENT_TIMESTAMP
		 WHERE user_id = $1`,
		userID,
	)
	if err != nil {
		return nil, err
	}

	// Update user
	_, err = tx.Exec(
		"UPDATE users SET mfa_enabled = true WHERE id = $1",
		userID,
	)
	if err != nil {
		return nil, err
	}

	// Generate backup codes
	backupCodes, err := s.GenerateBackupCodes(tx, userID, 10)
	if err != nil {
		return nil, err
	}

	if err := tx.Commit(); err != nil {
		return nil, err
	}

	return backupCodes, nil
}

// GenerateBackupCodes generates backup recovery codes
func (s *MFAService) GenerateBackupCodes(tx *sql.Tx, userID string, count int) ([]string, error) {
	// Delete old codes
	_, err := tx.Exec("DELETE FROM mfa_backup_codes WHERE user_id = $1", userID)
	if err != nil {
		return nil, err
	}

	codes := make([]string, count)

	for i := 0; i < count; i++ {
		// Generate 8-character code
		b := make([]byte, 4)
		rand.Read(b)
		code := fmt.Sprintf("%08X", b)

		_, err := tx.Exec(
			"INSERT INTO mfa_backup_codes (user_id, code) VALUES ($1, $2)",
			userID, code,
		)
		if err != nil {
			return nil, err
		}

		codes[i] = code
	}

	return codes, nil
}

// VerifyBackupCode verifies and uses a backup code
func (s *MFAService) VerifyBackupCode(userID, code string) (bool, error) {
	result, err := s.db.Exec(
		`UPDATE mfa_backup_codes
		 SET used = true, used_at = CURRENT_TIMESTAMP
		 WHERE user_id = $1 AND code = $2 AND used = false
		 RETURNING id`,
		userID, code,
	)

	if err != nil {
		return false, err
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}

	return rows > 0, nil
}

// IsMFAEnabled checks if MFA is enabled for user
func (s *MFAService) IsMFAEnabled(userID string) (bool, error) {
	var enabled bool
	err := s.db.QueryRow(
		"SELECT mfa_enabled FROM users WHERE id = $1",
		userID,
	).Scan(&enabled)

	return enabled, err
}

// GetMFASecret gets user's MFA secret if enabled
func (s *MFAService) GetMFASecret(userID string) (string, error) {
	var secret string
	err := s.db.QueryRow(
		"SELECT secret FROM mfa_secrets WHERE user_id = $1 AND enabled = true",
		userID,
	).Scan(&secret)

	if err == sql.ErrNoRows {
		return "", nil
	}

	return secret, err
}

// DisableMFA disables MFA for user
func (s *MFAService) DisableMFA(userID string) error {
	tx, err := s.db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	// Delete MFA secret
	_, err = tx.Exec("DELETE FROM mfa_secrets WHERE user_id = $1", userID)
	if err != nil {
		return err
	}

	// Delete backup codes
	_, err = tx.Exec("DELETE FROM mfa_backup_codes WHERE user_id = $1", userID)
	if err != nil {
		return err
	}

	// Update user
	_, err = tx.Exec("UPDATE users SET mfa_enabled = false WHERE id = $1", userID)
	if err != nil {
		return err
	}

	return tx.Commit()
}

// GetRemainingBackupCodes gets count of unused backup codes
func (s *MFAService) GetRemainingBackupCodes(userID string) (int, error) {
	var count int
	err := s.db.QueryRow(
		`SELECT COUNT(*) FROM mfa_backup_codes
		 WHERE user_id = $1 AND used = false`,
		userID,
	).Scan(&count)

	return count, err
}

// LogAttempt logs MFA attempt
func (s *MFAService) LogAttempt(userID string, success bool, ipAddress string) error {
	_, err := s.db.Exec(
		"INSERT INTO mfa_attempts (user_id, success, ip_address) VALUES ($1, $2, $3)",
		userID, success, ipAddress,
	)
	return err
}

// CheckRateLimit checks if user has exceeded rate limit
func (s *MFAService) CheckRateLimit(userID string) (bool, error) {
	var count int
	err := s.db.QueryRow(
		`SELECT COUNT(*) FROM mfa_attempts
		 WHERE user_id = $1
		   AND success = false
		   AND attempted_at > CURRENT_TIMESTAMP - INTERVAL '15 minutes'`,
		userID,
	).Scan(&count)

	if err != nil {
		return false, err
	}

	return count < 5, nil
}
```

**MFA Handler:**

```go
// handlers/mfa.go
package handlers

import (
	"encoding/json"
	"net/http"

	"myapp/middleware"
	"myapp/services"
)

type MFAHandler struct {
	mfaService *services.MFAService
	userRepo   *repositories.UserRepository
}

func NewMFAHandler(mfaService *services.MFAService, userRepo *repositories.UserRepository) *MFAHandler {
	return &MFAHandler{
		mfaService: mfaService,
		userRepo:   userRepo,
	}
}

// SetupMFA initiates MFA setup
func (h *MFAHandler) SetupMFA(w http.ResponseWriter, r *http.Request) {
	userID := r.Context().Value(middleware.UserIDKey).(string)

	// Get user email
	user, err := h.userRepo.FindByID(userID)
	if err != nil {
		http.Error(w, "User not found", http.StatusNotFound)
		return
	}

	// Generate secret and QR code
	setup, err := h.mfaService.GenerateSecret(user.Email, "My SaaS App")
	if err != nil {
		http.Error(w, "Failed to generate secret", http.StatusInternalServerError)
		return
	}

	// Save secret (not yet enabled)
	if err := h.mfaService.SaveSecret(userID, setup.Secret); err != nil {
		http.Error(w, "Failed to save secret", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message":    "MFA setup initiated",
		"secret":     setup.Secret,
		"qrCode":     setup.QRCode,
		"otpAuthUrl": setup.OTPAuthURL,
	})
}

// VerifyAndEnable verifies code and enables MFA
func (h *MFAHandler) VerifyAndEnable(w http.ResponseWriter, r *http.Request) {
	userID := r.Context().Value(middleware.UserIDKey).(string)

	var req struct {
		Code string `json:"code"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// Enable MFA
	backupCodes, err := h.mfaService.EnableMFA(userID, req.Code)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message":     "MFA enabled successfully",
		"backupCodes": backupCodes,
	})
}

// DisableMFA disables MFA
func (h *MFAHandler) DisableMFA(w http.ResponseWriter, r *http.Request) {
	userID := r.Context().Value(middleware.UserIDKey).(string)

	var req struct {
		Password string `json:"password"`
		Code     string `json:"code"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// Verify password
	user, err := h.userRepo.FindByID(userID)
	if err != nil || !user.CheckPassword(req.Password) {
		http.Error(w, "Invalid password", http.StatusUnauthorized)
		return
	}

	// Verify MFA code
	secret, err := h.mfaService.GetMFASecret(userID)
	if err != nil {
		http.Error(w, "Failed to get MFA secret", http.StatusInternalServerError)
		return
	}

	if secret != "" && !h.mfaService.VerifyCode(secret, req.Code) {
		http.Error(w, "Invalid MFA code", http.StatusBadRequest)
		return
	}

	// Disable MFA
	if err := h.mfaService.DisableMFA(userID); err != nil {
		http.Error(w, "Failed to disable MFA", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"message": "MFA disabled successfully",
	})
}

// VerifyMFAToken verifies MFA token during login
func (h *MFAHandler) VerifyMFAToken(w http.ResponseWriter, r *http.Request) {
	var req struct {
		UserID string `json:"userId"`
		Token  string `json:"token"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// Check rate limiting
	canAttempt, err := h.mfaService.CheckRateLimit(req.UserID)
	if err != nil || !canAttempt {
		http.Error(w, "Too many failed attempts", http.StatusTooManyRequests)
		return
	}

	// Get secret
	secret, err := h.mfaService.GetMFASecret(req.UserID)
	if err != nil || secret == "" {
		http.Error(w, "MFA not enabled", http.StatusBadRequest)
		return
	}

	// Verify token
	isValid := h.mfaService.VerifyCode(secret, req.Token)

	// Log attempt
	h.mfaService.LogAttempt(req.UserID, isValid, r.RemoteAddr)

	if !isValid {
		http.Error(w, "Invalid MFA code", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message":  "MFA verification successful",
		"verified": true,
	})
}

// VerifyBackupCode verifies backup code
func (h *MFAHandler) VerifyBackupCode(w http.ResponseWriter, r *http.Request) {
	var req struct {
		UserID string `json:"userId"`
		Code   string `json:"code"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// Verify backup code
	isValid, err := h.mfaService.VerifyBackupCode(req.UserID, req.Code)
	if err != nil {
		http.Error(w, "Verification failed", http.StatusInternalServerError)
		return
	}

	// Log attempt
	h.mfaService.LogAttempt(req.UserID, isValid, r.RemoteAddr)

	if !isValid {
		http.Error(w, "Invalid backup code", http.StatusBadRequest)
		return
	}

	// Check remaining codes
	remaining, _ := h.mfaService.GetRemainingBackupCodes(req.UserID)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message":        "Backup code verified successfully",
		"verified":       true,
		"remainingCodes": remaining,
		"warning":        if remaining <= 2 { "Running low on backup codes" } else { nil },
	})
}

// GetMFAStatus gets MFA status
func (h *MFAHandler) GetMFAStatus(w http.ResponseWriter, r *http.Request) {
	userID := r.Context().Value(middleware.UserIDKey).(string)

	enabled, err := h.mfaService.IsMFAEnabled(userID)
	if err != nil {
		http.Error(w, "Failed to get MFA status", http.StatusInternalServerError)
		return
	}

	var remainingCodes int
	if enabled {
		remainingCodes, _ = h.mfaService.GetRemainingBackupCodes(userID)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"mfaEnabled":         enabled,
		"remainingBackupCodes": remainingCodes,
	})
}
```

**Router Setup:**

```go
// Setup MFA routes
mfaHandler := handlers.NewMFAHandler(mfaService, userRepo)

api.HandleFunc("/mfa/setup", mfaHandler.SetupMFA).Methods("POST")
api.HandleFunc("/mfa/verify-enable", mfaHandler.VerifyAndEnable).Methods("POST")
api.HandleFunc("/mfa/disable", mfaHandler.DisableMFA).Methods("POST")
api.HandleFunc("/mfa/status", mfaHandler.GetMFAStatus).Methods("GET")

// Public routes for login MFA verification
r.HandleFunc("/api/auth/mfa/verify", mfaHandler.VerifyMFAToken).Methods("POST")
r.HandleFunc("/api/auth/mfa/verify-backup", mfaHandler.VerifyBackupCode).Methods("POST")
```

---

## üìñ Section 6: Recovery Flows

### 5.9 Account Recovery When MFA Device is Lost

**Recovery Options:**

1. **Backup Codes** - User saved codes during setup
2. **Recovery Email** - Send code to verified recovery email
3. **Admin Override** - Support team can disable MFA
4. **Identity Verification** - Answer security questions

**Recovery Email Flow:**

```typescript
// src/services/mfa-recovery.service.ts
import crypto from "crypto";
import { pool } from "../config/database";
import { EmailService } from "./email.service";

export class MFARecoveryService {
  /**
   * Initiate MFA recovery
   */
  static async initiateRecovery(email: string): Promise {
    // Find user
    const user = await User.findByEmail(email);
    if (!user) {
      // Don't reveal if user exists
      return;
    }

    // Check if MFA is enabled
    const mfaEnabled = await MFAService.isMFAEnabled(user.id);
    if (!mfaEnabled) {
      return;
    }

    // Generate recovery token
    const token = crypto.randomBytes(32).toString("hex");
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

    // Save token
    const query = `
      INSERT INTO mfa_recovery_tokens (user_id, token, expires_at)
      VALUES ($1, $2, $3)
      ON CONFLICT (user_id)
      DO UPDATE SET token = $2, expires_at = $3, used = false
    `;

    await pool.query(query, [user.id, token, expiresAt]);

    // Send recovery email
    await EmailService.send({
      to: email,
      subject: "MFA Account Recovery",
      template: "mfa-recovery",
      data: {
        recoveryLink: `${process.env.FRONTEND_URL}/auth/mfa-recovery?token=${token}`,
        expiresIn: "1 hour",
      },
    });
  }

  /**
   * Verify recovery token and disable MFA
   */
  static async verifyRecoveryToken(
    token: string,
    newPassword: string
  ): Promise {
    const query = `
      SELECT user_id
      FROM mfa_recovery_tokens
      WHERE token = $1 
        AND expires_at > CURRENT_TIMESTAMP
        AND used = false
    `;

    const result = await pool.query(query, [token]);

    if (result.rows.length === 0) {
      return false;
    }

    const userId = result.rows[0].user_id;

    // Begin transaction
    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      // Disable MFA
      await MFAService.disableMFA(userId);

      // Update password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      await client.query("UPDATE users SET password = $1 WHERE id = $2", [
        hashedPassword,
        userId,
      ]);

      // Mark token as used
      await client.query(
        "UPDATE mfa_recovery_tokens SET used = true WHERE token = $1",
        [token]
      );

      await client.query("COMMIT");

      // Send notification email
      const user = await User.findById(userId);
      await EmailService.send({
        to: user!.email,
        subject: "MFA Disabled via Account Recovery",
        template: "mfa-disabled-notification",
      });

      return true;
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  }
}
```

**Database Schema:**

```sql
CREATE TABLE mfa_recovery_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  token VARCHAR(64) NOT NULL,
  used BOOLEAN DEFAULT FALSE,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_recovery_token ON mfa_recovery_tokens(token);
CREATE INDEX idx_recovery_expiry ON mfa_recovery_tokens(expires_at);
```

**Recovery Controller:**

```typescript
export class MFARecoveryController {
  static async initiateRecovery(req: Request, res: Response) {
    const { email } = req.body;

    // Always return success (don't reveal if email exists)
    await MFARecoveryService.initiateRecovery(email);

    res.json({
      message:
        "If this email is registered with MFA enabled, you will receive recovery instructions",
    });
  }

  static async verifyRecovery(req: Request, res: Response) {
    const { token, newPassword } = req.body;

    // Validate password
    const validation = validatePassword(newPassword);
    if (!validation.valid) {
      return res.status(400).json({ errors: validation.errors });
    }

    const success = await MFARecoveryService.verifyRecoveryToken(
      token,
      newPassword
    );

    if (!success) {
      return res
        .status(400)
        .json({ error: "Invalid or expired recovery token" });
    }

    res.json({
      message:
        "MFA disabled and password reset successfully. Please login with your new password.",
    });
  }
}
```

---

## üìñ Section 7: Admin MFA Enforcement

### 5.10 Force MFA for Specific Users/Roles

**Use Cases:**

- Require MFA for all admins
- Require MFA for users accessing sensitive data
- Require MFA based on IP location
- Require MFA after security incident

**Database Schema:**

```sql
ALTER TABLE users ADD COLUMN mfa_required BOOLEAN DEFAULT FALSE;
ALTER TABLE users ADD COLUMN mfa_required_by TIMESTAMP;
ALTER TABLE users ADD COLUMN mfa_required_reason TEXT;

-- Role-based MFA requirements
CREATE TABLE role_mfa_requirements (
  role_name VARCHAR(50) PRIMARY KEY,
  mfa_required BOOLEAN DEFAULT TRUE,
  grace_period_days INTEGER DEFAULT 7,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert default requirements
INSERT INTO role_mfa_requirements (role_name, mfa_required, grace_period_days)
VALUES
  ('admin', TRUE, 3),
  ('super_admin', TRUE, 0),
  ('manager', TRUE, 7);
```

**MFA Enforcement Service:**

```typescript
// src/services/mfa-enforcement.service.ts
export class MFAEnforcementService {
  /**
   * Check if user is required to enable MFA
   */
  static async isMFARequired(userId: string): Promise {
    const query = `
      SELECT 
        u.mfa_required,
        u.mfa_enabled,
        u.mfa_required_by,
        u.mfa_required_reason,
        r.role_name,
        rmr.mfa_required as role_mfa_required,
        rmr.grace_period_days
      FROM users u
      LEFT JOIN user_roles ur ON u.id = ur.user_id
      LEFT JOIN roles r ON ur.role_id = r.id
      LEFT JOIN role_mfa_requirements rmr ON r.name = rmr.role_name
      WHERE u.id = $1
    `;

    const result = await pool.query(query, [userId]);

    if (result.rows.length === 0) {
      return { required: false };
    }

    const row = result.rows[0];

    // Already has MFA enabled
    if (row.mfa_enabled) {
      return { required: false };
    }

    // Explicitly required for user
    if (row.mfa_required) {
      const gracePeriodEnds = new Date(row.mfa_required_by);
      gracePeriodEnds.setDate(gracePeriodEnds.getDate() + 7); // Default 7 days grace period

      return {
        required: true,
        gracePeriodEnds,
        reason: row.mfa_required_reason || "Security policy requires MFA",
      };
    }

    // Required by role
    if (row.role_mfa_required) {
      const gracePeriodEnds = new Date();
      gracePeriodEnds.setDate(
        gracePeriodEnds.getDate() + row.grace_period_days
      );

      return {
        required: true,
        gracePeriodEnds,
        reason: `MFA required for ${row.role_name} role`,
      };
    }

    return { required: false };
  }

  /**
   * Require MFA for specific user
   */
  static async requireMFAForUser(
    userId: string,
    reason: string,
    requiredBy: string
  ): Promise {
    const query = `
      UPDATE users
      SET 
        mfa_required = TRUE,
        mfa_required_by = CURRENT_TIMESTAMP,
        mfa_required_reason = $2
      WHERE id = $1
    `;

    await pool.query(query, [userId, reason]);

    // Send notification email
    const user = await User.findById(userId);
    await EmailService.send({
      to: user!.email,
      subject: "MFA Now Required for Your Account",
      template: "mfa-required-notification",
      data: {
        reason,
        gracePeriod: 7,
        setupUrl: `${process.env.FRONTEND_URL}/settings/security/mfa`,
      },
    });

    // Log action
    await AuditLog.create({
      action: "mfa_required",
      userId: requiredBy,
      targetUserId: userId,
      details: { reason },
    });
  }

  /**
   * Require MFA for all users with specific role
   */
  static async requireMFAForRole(
    roleName: string,
    gracePeriodDays: number = 7
  ): Promise {
    const query = `
      INSERT INTO role_mfa_requirements (role_name, mfa_required, grace_period_days)
      VALUES ($1, TRUE, $2)
      ON CONFLICT (role_name)
      DO UPDATE SET mfa_required = TRUE, grace_period_days = $2
    `;

    await pool.query(query, [roleName, gracePeriodDays]);

    // Notify all users with this role
    const users = await pool.query(
      `
      SELECT DISTINCT u.id, u.email
      FROM users u
      INNER JOIN user_roles ur ON u.id = ur.user_id
      INNER JOIN roles r ON ur.role_id = r.id
      WHERE r.name = $1 AND u.mfa_enabled = FALSE
    `,
      [roleName]
    );

    for (const user of users.rows) {
      await EmailService.send({
        to: user.email,
        subject: "MFA Now Required for Your Account",
        template: "mfa-required-notification",
        data: {
          reason: `Required for ${roleName} role`,
          gracePeriod: gracePeriodDays,
          setupUrl: `${process.env.FRONTEND_URL}/settings/security/mfa`,
        },
      });
    }
  }
}
```

**Enforcement Middleware:**

```typescript
// src/middleware/mfa-enforcement.middleware.ts
export async function enforceMFA(
  req: Request,
  res: Response,
  next: NextFunction
) {
  if (!req.user) {
    return next();
  }

  const userId = req.user.userId;

  // Check if MFA is required
  const requirement = await MFAEnforcementService.isMFARequired(userId);

  if (requirement.required) {
    const now = new Date();

    // Check if grace period has expired
    if (requirement.gracePeriodEnds && now > requirement.gracePeriodEnds) {
      return res.status(403).json({
        error: "MFA setup required",
        message:
          "Your grace period has expired. Please set up MFA to continue.",
        setupUrl: "/settings/security/mfa",
        reason: requirement.reason,
      });
    }

    // Still in grace period - show warning
    if (requirement.gracePeriodEnds) {
      res.setHeader("X-MFA-Required", "true");
      res.setHeader(
        "X-MFA-Grace-Period-Ends",
        requirement.gracePeriodEnds.toISOString()
      );
    }
  }

  next();
}

// Apply to protected routes
app.use("/api", authenticateJWT, enforceMFA);
```

**Admin Controller:**

```typescript
export class AdminMFAController {
  /**
   * Require MFA for specific user
   */
  static async requireMFAForUser(req: Request, res: Response) {
    const { userId, reason } = req.body;
    const adminId = req.user!.userId;

    await MFAEnforcementService.requireMFAForUser(userId, reason, adminId);

    res.json({
      message: "MFA requirement set for user",
      userId,
    });
  }

  /**
   * Require MFA for role
   */
  static async requireMFAForRole(req: Request, res: Response) {
    const { roleName, gracePeriodDays } = req.body;

    await MFAEnforcementService.requireMFAForRole(roleName, gracePeriodDays);

    res.json({
      message: `MFA requirement set for ${roleName} role`,
      gracePeriodDays,
    });
  }

  /**
   * Disable MFA for user (admin override)
   */
  static async disableMFAForUser(req: Request, res: Response) {
    const { userId, reason } = req.body;
    const adminId = req.user!.userId;

    // Disable MFA
    await MFAService.disableMFA(userId);

    // Log action
    await AuditLog.create({
      action: "mfa_disabled_by_admin",
      userId: adminId,
      targetUserId: userId,
      details: { reason },
    });

    // Notify user
    const user = await User.findById(userId);
    await EmailService.send({
      to: user!.email,
      subject: "MFA Disabled by Administrator",
      template: "mfa-admin-disabled",
      data: { reason },
    });

    res.json({
      message: "MFA disabled for user",
      userId,
    });
  }
}
```

---

## üìñ Section 8: MFA Best Practices & Security

### 5.11 Security Best Practices

**Rate Limiting:**

```typescript
// Implement exponential backoff for failed attempts
const RATE_LIMITS = {
  attempts: [1, 2, 3, 5, 10], // Failed attempts
  delays: [0, 30, 60, 300, 900], // Delays in seconds
};

export async function checkMFARateLimit(userId: string): Promise {
  const query = `
    SELECT COUNT(*) as failed_attempts
    FROM mfa_attempts
    WHERE user_id = $1 
      AND success = false 
      AND attempted_at > CURRENT_TIMESTAMP - INTERVAL '1 hour'
  `;

  const result = await pool.query(query, [userId]);
  const failedAttempts = parseInt(result.rows[0].failed_attempts);

  // Find delay for current attempt count
  let delayIndex = RATE_LIMITS.attempts.findIndex((a) => failedAttempts < a);
  if (delayIndex === -1) delayIndex = RATE_LIMITS.delays.length - 1;

  const delay = RATE_LIMITS.delays[delayIndex];

  if (delay > 0) {
    return {
      allowed: false,
      retryAfter: delay,
    };
  }

  return { allowed: true };
}
```

**Backup Code Security:**

```typescript
// Hash backup codes before storing
import crypto from "crypto";

function hashBackupCode(code: string): string {
  return crypto.createHash("sha256").update(code).digest("hex");
}

// Store hashed version
await pool.query(
  "INSERT INTO mfa_backup_codes (user_id, code_hash) VALUES ($1, $2)",
  [userId, hashBackupCode(code)]
);

// Verify hashed code
const result = await pool.query(
  "SELECT id FROM mfa_backup_codes WHERE user_id = $1 AND code_hash = $2 AND used = false",
  [userId, hashBackupCode(inputCode)]
);
```

**Audit Logging:**

```typescript
// Log all MFA-related events
export class MFAAuditService {
  static async logEvent(event: {
    userId: string;
    action: string;
    success: boolean;
    ipAddress: string;
    userAgent?: string;
    details?: any;
  }): Promise<void> {
    await pool.query(
      `INSERT INTO mfa_audit_log (user_id, action, success, ip_address, user_agent, details)
       VALUES ($1, $2, $3, $4, $5, $6)`,
      [
        event.userId,
        event.action,
        event.success,
        event.ipAddress,
        event.userAgent,
        JSON.stringify(event.details || {}),
      ]
    );
  }
}

// Usage
await MFAAuditService.logEvent({
  userId,
  action: "mfa_verification",
  success: true,
  ipAddress: req.ip,
  userAgent: req.headers["user-agent"],
});
```

---

### 5.12 User Experience Considerations

**Progressive Enrollment:**

```typescript
// Suggest MFA after user has been active for a period
export class MFASuggestionService {
  static async shouldSuggestMFA(userId: string): Promise {
    const user = await User.findById(userId);

    // Don't suggest if already enabled
    if (user.mfaEnabled) return false;

    // Suggest after 7 days of account age
    const accountAge = Date.now() - user.createdAt.getTime();
    const sevenDays = 7 * 24 * 60 * 60 * 1000;

    if (accountAge < sevenDays) return false;

    // Suggest after 10 logins
    const loginCount = await pool.query(
      "SELECT COUNT(*) FROM login_history WHERE user_id = $1",
      [userId]
    );

    return parseInt(loginCount.rows[0].count) >= 10;
  }
}
```

**Friendly Error Messages:**

```typescript
const MFA_ERROR_MESSAGES = {
  INVALID_CODE: {
    message: "The code you entered is incorrect. Please try again.",
    hint: "Make sure you're entering the current 6-digit code from your authenticator app.",
  },
  EXPIRED_CODE: {
    message: "This code has expired.",
    hint: "Codes change every 30 seconds. Please enter the current code.",
  },
  RATE_LIMITED: {
    message: "Too many failed attempts.",
    hint: "Please wait {retryAfter} seconds before trying again.",
  },
  BACKUP_CODE_USED: {
    message: "This backup code has already been used.",
    hint: "Each backup code can only be used once. Try another code or use your authenticator app.",
  },
  LOW_BACKUP_CODES: {
    message: "You're running low on backup codes.",
    hint: "You have {remaining} backup codes left. Generate new ones in your security settings.",
  },
};
```

---

### 5.13 Testing MFA Implementation

**Unit Tests (Node.js/Jest):**

```typescript
// tests/services/mfa.service.test.ts
import { MFAService } from "../../src/services/mfa.service";
import speakeasy from "speakeasy";

describe("MFAService", () => {
  describe("generateSecret", () => {
    it("should generate a valid secret", () => {
      const { secret, otpauthUrl } =
        MFAService.generateSecret("test@example.com");

      expect(secret).toBeDefined();
      expect(secret.length).toBeGreaterThan(0);
      expect(otpauthUrl).toContain("otpauth://");
      expect(otpauthUrl).toContain("test@example.com");
    });
  });

  describe("verifyToken", () => {
    it("should verify valid TOTP token", () => {
      const secret = speakeasy.generateSecret().base32;
      const token = speakeasy.totp({
        secret,
        encoding: "base32",
      });

      const isValid = MFAService.verifyToken(secret, token);
      expect(isValid).toBe(true);
    });

    it("should reject invalid token", () => {
      const secret = speakeasy.generateSecret().base32;
      const isValid = MFAService.verifyToken(secret, "000000");

      expect(isValid).toBe(false);
    });
  });

  describe("generateBackupCodes", () => {
    it("should generate specified number of codes", () => {
      const codes = MFAService.generateBackupCodes(10);

      expect(codes).toHaveLength(10);
      expect(codes[0]).toMatch(/^[0-9A-F]{8}$/);
    });

    it("should generate unique codes", () => {
      const codes = MFAService.generateBackupCodes(10);
      const uniqueCodes = new Set(codes);

      expect(uniqueCodes.size).toBe(10);
    });
  });
});
```

**Integration Tests:**

```typescript
// tests/integration/mfa-flow.test.ts
import request from "supertest";
import app from "../../src/app";

describe("MFA Flow", () => {
  let authToken: string;
  let userId: string;

  beforeAll(async () => {
    // Create test user and login
    const response = await request(app).post("/api/auth/register").send({
      email: "mfatest@example.com",
      password: "TestPassword123!",
      name: "MFA Test User",
    });

    authToken = response.body.accessToken;
    userId = response.body.user.id;
  });

  it("should complete full MFA setup flow", async () => {
    // Step 1: Setup MFA
    const setupResponse = await request(app)
      .post("/api/mfa/setup")
      .set("Authorization", `Bearer ${authToken}`)
      .send();

    expect(setupResponse.status).toBe(200);
    expect(setupResponse.body.secret).toBeDefined();
    expect(setupResponse.body.qrCode).toBeDefined();

    const secret = setupResponse.body.secret;

    // Step 2: Generate valid TOTP code
    const token = speakeasy.totp({
      secret,
      encoding: "base32",
    });

    // Step 3: Verify and enable MFA
    const verifyResponse = await request(app)
      .post("/api/mfa/verify-enable")
      .set("Authorization", `Bearer ${authToken}`)
      .send({ token });

    expect(verifyResponse.status).toBe(200);
    expect(verifyResponse.body.backupCodes).toHaveLength(10);

    // Step 4: Verify MFA is enabled
    const statusResponse = await request(app)
      .get("/api/mfa/status")
      .set("Authorization", `Bearer ${authToken}`);

    expect(statusResponse.body.mfaEnabled).toBe(true);
  });

  it("should require MFA during login", async () => {
    // Login with credentials only
    const loginResponse = await request(app).post("/api/auth/login").send({
      email: "mfatest@example.com",
      password: "TestPassword123!",
    });

    expect(loginResponse.status).toBe(200);
    expect(loginResponse.body.requiresMFA).toBe(true);
    expect(loginResponse.body.userId).toBeDefined();
  });
});
```

---

## üìñ Section 9: Frontend Integration Examples

### 5.14 React MFA Setup Component

```typescript
// components/MFASetup.tsx
import React, { useState } from 'react';
import QRCode from 'qrcode.react';

interface MFASetupProps {
  onComplete: () => void;
}

export const MFASetup: React.FC = ({ onComplete }) => {
  const [step, setStep] = useState('setup');
  const [secret, setSecret] = useState('');
  const [qrCode, setQRCode] = useState('');
  const [verificationCode, setVerificationCode] = useState('');
  const [backupCodes, setBackupCodes] = useState([]);
  const [error, setError] = useState('');

  const handleSetup = async () => {
    try {
      const response = await fetch('/api/mfa/setup', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
          'Content-Type': 'application/json'
        }
      });

      const data = await response.json();
      setSecret(data.secret);
      setQRCode(data.qrCode);
      setStep('verify');
    } catch (err) {
      setError('Failed to setup MFA');
    }
  };

  const handleVerify = async () => {
    try {
      const response = await fetch('/api/mfa/verify-enable', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ token: verificationCode })
      });

      if (!response.ok) {
        throw new Error('Invalid code');
      }

      const data = await response.json();
      setBackupCodes(data.backupCodes);
      setStep('backup');
    } catch (err) {
      setError('Invalid verification code');
    }
  };

  const handleDownloadBackupCodes = () => {
    const text = backupCodes.join('\n');
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'mfa-backup-codes.txt';
    a.click();
  };

  return (

      {step === 'setup' && (

          Set Up Two-Factor Authentication
          Add an extra layer of security to your account
          Get Started

      )}

      {step === 'verify' && (

          Scan QR Code
          Use Google Authenticator or Authy to scan this code:






            Can't scan? Enter this code manually:
            {secret}



            Enter 6-digit code from your app:
            <input
              type="text"
              maxLength={6}
              value={verificationCode}
              onChange={(e) => setVerificationCode(e.target.value.replace(/\D/g, ''))}
              placeholder="000000"
            />
            Verify and Enable


          {error && {error}}

      )}

      {step === 'backup' && (

          Save Your Backup Codes

            ‚ö†Ô∏è Save these codes in a secure place. Each code can only be used once.



            {backupCodes.map((code, index) => (
              {code}
            ))}



            Download Codes
            I've Saved My Codes


      )}

  );
};
```

**MFA Login Component:**

```typescript
// components/MFALogin.tsx
import React, { useState } from 'react';

interface MFALoginProps {
  userId: string;
  onSuccess: (tokens: { accessToken: string; refreshToken: string }) => void;
}

export const MFALogin: React.FC = ({ userId, onSuccess }) => {
  const [code, setCode] = useState('');
  const [useBackupCode, setUseBackupCode] = useState(false);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleVerify = async () => {
    setLoading(true);
    setError('');

    try {
      const endpoint = useBackupCode
        ? '/api/auth/mfa/verify-backup'
        : '/api/auth/mfa/verify';

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, [useBackupCode ? 'code' : 'token']: code })
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error);
      }

      // Complete login flow
      const loginResponse = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          mfaToken: useBackupCode ? undefined : code,
          backupCode: useBackupCode ? code : undefined
        })
      });

      const data = await loginResponse.json();
      onSuccess({
        accessToken: data.accessToken,
        refreshToken: data.refreshToken
      });
    } catch (err: any) {
      setError(err.message || 'Verification failed');
    } finally {
      setLoading(false);
    }
  };

  return (

      Two-Factor Authentication

      {!useBackupCode ? (

          Enter the 6-digit code from your authenticator app:
          <input
            type="text"
            maxLength={6}
            value={code}
            onChange={(e) => setCode(e.target.value.replace(/\D/g, ''))}
            placeholder="000000"
            autoFocus
          />

      ) : (

          Enter one of your backup codes:
          <input
            type="text"
            maxLength={8}
            value={code}
            onChange={(e) => setCode(e.target.value.toUpperCase())}
            placeholder="ABCD1234"
            autoFocus
          />

      )}

      {error && {error}}


        {loading ? 'Verifying...' : 'Verify'}


      <button
        className="link-button"
        onClick={() => {
          setUseBackupCode(!useBackupCode);
          setCode('');
          setError('');
        }}
      >
        {useBackupCode ? 'Use authenticator app' : 'Use backup code'}


  );
};
```

---

## üìö Additional Resources

### Libraries & Tools

**TOTP Libraries:**

- **Node.js:** `speakeasy`, `otplib`, `node-2fa`
- **Java:** `googleauth`, `totp-me`
- **Go:** `github.com/pquerna/otp`, `github.com/xlzd/gotp`

**QR Code Generation:**

- **Node.js:** `qrcode`, `qrcode-generator`
- **Java:** `zxing` (Google's QR code library)
- **Go:** `github.com/skip2/go-qrcode`

**Authenticator Apps:**

- Google Authenticator (iOS, Android)
- Authy (iOS, Android, Desktop)
- Microsoft Authenticator
- 1Password
- Bitwarden

### Documentation

- **RFC 6238 (TOTP):** https://tools.ietf.org/html/rfc6238
- **RFC 4226 (HOTP):** https://tools.ietf.org/html/rfc4226
- **OWASP MFA Cheat Sheet:** https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html
- **Twilio Verify API:** https://www.twilio.com/docs/verify/api

### Security Considerations

**TOTP Security:**

- ‚úÖ Secret must be at least 160 bits (20 bytes)
- ‚úÖ Use SHA-256 or SHA-512 (not MD5/SHA-1)
- ‚úÖ Time window should be 30 seconds
- ‚úÖ Allow 1-2 time steps before/after for clock drift
- ‚úÖ Rate limit verification attempts

**Backup Codes:**

- ‚úÖ Hash codes before storing (SHA-256)
- ‚úÖ Generate 8-10 codes initially
- ‚úÖ Each code single-use only
- ‚úÖ Warn when codes running low (< 3 remaining)
- ‚úÖ Allow regeneration with MFA verification

**SMS Security:**

- ‚ö†Ô∏è Vulnerable to SIM swapping
- ‚ö†Ô∏è Can be intercepted
- ‚úÖ Use as fallback, not primary MFA
- ‚úÖ Consider regional restrictions
- ‚úÖ Implement rate limiting

---

## ‚úÖ Day 5 Complete Checklist

By the end of this day, you should have:

- [ ] Understood different MFA methods and their trade-offs
- [ ] Implemented TOTP-based MFA in Node.js/TypeScript
- [ ] Implemented TOTP-based MFA in Java/Spring Boot
- [ ] Implemented TOTP-based MFA in Go
- [ ] Set up SMS-based MFA with Twilio
- [ ] Implemented email-based MFA as fallback
- [ ] Created backup/recovery codes system
- [ ] Built "remember this device" functionality
- [ ] Implemented account recovery flows
- [ ] Added admin MFA enforcement
- [ ] Implemented rate limiting and security measures
- [ ] Created frontend integration examples
- [ ] Written tests for MFA functionality

---

## üí° Key Takeaways

1. **TOTP is the gold standard** - Most secure and cost-effective MFA method for SaaS

2. **Always provide backup codes** - Users will lose their devices, plan for recovery

3. **Rate limiting is critical** - Prevent brute force attacks on MFA codes

4. **User experience matters** - Make MFA setup easy, provide clear instructions

5. **Multiple recovery methods** - Backup codes, recovery email, admin override

6. **Audit everything** - Log all MFA events for security monitoring

7. **Progressive enrollment** - Suggest MFA after user is established, don't force immediately

8. **Test thoroughly** - MFA lockouts are extremely frustrating for users

9. **Support common apps** - Google Authenticator, Authy are most widely used

10. **Plan for enforcement** - Be able to require MFA for admins/sensitive roles

---
